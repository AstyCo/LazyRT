// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILETREE_UTESTRUNNER_H_
#define FLATBUFFERS_GENERATED_FILETREE_UTESTRUNNER_H_

#include "flatbuffers/flatbuffers.h"

namespace UTestRunner {

struct FileRecord;

struct FileTree;

struct FileRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_MD5 = 6,
    VT_INCLUDES = 8,
    VT_DEPENDSON = 10
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  const flatbuffers::Vector<uint8_t> *md5() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MD5);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *includes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INCLUDES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dependsOn() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEPENDSON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyOffset(verifier, VT_MD5) &&
           verifier.Verify(md5()) &&
           VerifyOffset(verifier, VT_INCLUDES) &&
           verifier.Verify(includes()) &&
           verifier.VerifyVectorOfStrings(includes()) &&
           VerifyOffset(verifier, VT_DEPENDSON) &&
           verifier.Verify(dependsOn()) &&
           verifier.VerifyVectorOfStrings(dependsOn()) &&
           verifier.EndTable();
  }
};

struct FileRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(FileRecord::VT_PATH, path);
  }
  void add_md5(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> md5) {
    fbb_.AddOffset(FileRecord::VT_MD5, md5);
  }
  void add_includes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> includes) {
    fbb_.AddOffset(FileRecord::VT_INCLUDES, includes);
  }
  void add_dependsOn(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dependsOn) {
    fbb_.AddOffset(FileRecord::VT_DEPENDSON, dependsOn);
  }
  explicit FileRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileRecordBuilder &operator=(const FileRecordBuilder &);
  flatbuffers::Offset<FileRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileRecord> CreateFileRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> md5 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> includes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dependsOn = 0) {
  FileRecordBuilder builder_(_fbb);
  builder_.add_dependsOn(dependsOn);
  builder_.add_includes(includes);
  builder_.add_md5(md5);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileRecord> CreateFileRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    const std::vector<uint8_t> *md5 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *includes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dependsOn = nullptr) {
  return UTestRunner::CreateFileRecord(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      md5 ? _fbb.CreateVector<uint8_t>(*md5) : 0,
      includes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*includes) : 0,
      dependsOn ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dependsOn) : 0);
}

struct FileTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOTPATH = 4,
    VT_RECORDS = 6
  };
  const flatbuffers::String *rootPath() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOTPATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FileRecord>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FileRecord>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOTPATH) &&
           verifier.Verify(rootPath()) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.Verify(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct FileTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rootPath(flatbuffers::Offset<flatbuffers::String> rootPath) {
    fbb_.AddOffset(FileTree::VT_ROOTPATH, rootPath);
  }
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileRecord>>> records) {
    fbb_.AddOffset(FileTree::VT_RECORDS, records);
  }
  explicit FileTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileTreeBuilder &operator=(const FileTreeBuilder &);
  flatbuffers::Offset<FileTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileTree>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileTree> CreateFileTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> rootPath = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileRecord>>> records = 0) {
  FileTreeBuilder builder_(_fbb);
  builder_.add_records(records);
  builder_.add_rootPath(rootPath);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileTree> CreateFileTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *rootPath = nullptr,
    const std::vector<flatbuffers::Offset<FileRecord>> *records = nullptr) {
  return UTestRunner::CreateFileTree(
      _fbb,
      rootPath ? _fbb.CreateString(rootPath) : 0,
      records ? _fbb.CreateVector<flatbuffers::Offset<FileRecord>>(*records) : 0);
}

inline const UTestRunner::FileTree *GetFileTree(const void *buf) {
  return flatbuffers::GetRoot<UTestRunner::FileTree>(buf);
}

inline const UTestRunner::FileTree *GetSizePrefixedFileTree(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<UTestRunner::FileTree>(buf);
}

inline bool VerifyFileTreeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UTestRunner::FileTree>(nullptr);
}

inline bool VerifySizePrefixedFileTreeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UTestRunner::FileTree>(nullptr);
}

inline void FinishFileTreeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UTestRunner::FileTree> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFileTreeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UTestRunner::FileTree> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace UTestRunner

#endif  // FLATBUFFERS_GENERATED_FILETREE_UTESTRUNNER_H_
